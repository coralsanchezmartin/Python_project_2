

def list_of_colons(list_post, column):
    """
    Takes the values that contain colons
    :param list_post: list from where you want to extract the values
    :param column: specific column of the list
    :return: list_colons, a list of the values containing colons and count, the total number of values from the list.
    """
    list_colons = []  # creating a list
    count = 0  # The count starts at 0
    for linea_i in list_post:  # runs every element of the list.
        if linea_i[column].__contains__(","):  # see if an specific column contains the element ","
            list_colons.append(linea_i)  # if this is fulfilled then add the line containing this value to the list.
            count += 1  # every time you add a value count +1

    return list_colons, count


def represents_int(s):
    """
    Checks if a string is an integer
    :param s: the string that it checks to see if is an integer.
    :return: True, if the string is an integer and False if not.
    """
    try:
        int(s)
        return True
    except ValueError:
        return False


def represents_float(s):
    """
    Checks if a string is a float
    :param s: the string that it checks to see if is a float.
    :return: True, if the string is an float and False if not.
    """
    try:
        float(s)
        return True
    except ValueError:
        return False


def positives(list_post, upper_post, column):
    """
    Takes the positive values from a list generating a new list with only the values meeting the requirements.
    :param list_post: is from where you want to extract the values.
    :param upper_post: upper constant.
    :param column: the specific column where the number that we are looking for is at.
    :return: the new list generated by adding the values that meet the if requirements and the count.
    """
    list_post_complete = []  # creating a new list
    count = 0  # The list starts at 0
    for linea_i in list_post:  # runs every element of the list
        # calls the methods to check whether the value in the specific column (linea_i[column]) is a float or an integer
        if represents_int(linea_i[column]) or represents_float(linea_i[column]):
            # checks if the value is contained between 0 and the upper_post constant.
            if 0 <= float(linea_i[column]) < upper_post:
                list_post_complete.append(linea_i)  # add the line containing this value to the list.
                count += 1  # It adds 1 with each new element added to the list.

    return list_post_complete, count


def negatives(list_post, lower_post, column):
    """
    Takes the negative values from a list generating a new list with only the values meeting the requirements.
    :param list_post: the list from where we extract the values.
    :param lower_post: lower constant.
    :param column: the specific column where the number that we are looking for is at.
    :return: the new list generated by adding the values that meet the if requirements
             and the count of this new list.
    """
    list_neg_complete = []  # creating a new list.
    count = 0  # count starts at 0
    for linea_i in list_post:  # runs every element of the list
        # checks check whether the value in the specific column (linea_i[column]) is a float or an integer
        if represents_int(linea_i[column]) or represents_float(linea_i[column]):
            # checks if the value is between 0 and the lower constant.
            if 0 > float(linea_i[column]) > lower_post:
                list_neg_complete.append(linea_i)  # add the line containing this value to the new list.
                count += 1  # It adds 1 with each new element added to the list.

    return list_neg_complete, count


def outliers(list_post, upper_post, lower_post, column, bol_positives, bol_negatives):
    """
    Takes the outlier values from a list generating a new list with only the values meeting the requirements.
    :param list_post: the list from where we extract the values.
    :param upper_post: upper constant
    :param lower_post: lower constant
    :param column: specific column where the value we want is at
    :param bol_positives: boolean to indicate if we take into consideration the positive values
    :param bol_negatives: boolean to indicate if we take into consideration the negative values
    :return: the new list generated by adding the values that meet the if requirements
             and the count of this new list.
    """
    list_outliers_complete = []  # creating a new list
    count = 0   # counts starts at 0.
    for linea_i in list_post:  # runs every item of the list.
        # checks if the value is an integer or a float.
        if represents_int(linea_i[column]) or represents_float(linea_i[column]):

            # check the booleans to see if it need to run the positives if.
            if bol_positives is True and bol_negatives is False:
                if float(linea_i[column]) > upper_post:  # checks if the value is over the upper constant.
                    list_outliers_complete.append(linea_i)  # adds this line containing the value to the new list
                    count += 1  # It adds 1 with each new element added to the list.

            # check the booleans to see if it need to run the negatives if.
            if bol_negatives is True and bol_positives is False:
                if float(linea_i[column]) < lower_post:  # checks if the value is under the lower constant.
                    list_outliers_complete.append(linea_i) # adds this line containing the value to the new list
                    count += 1  # It adds 1 with each new element added to the list.

    return list_outliers_complete, count


def null(list_null, equal_null, column):
    """
    Takes the null values from a list generating a new list with only the values meeting the requirements.
    :param list_null: the list from where we extract the values
    :param equal_null: the string that the requirements need to match
    :param column: the specific column where the value that we are looking for is at.
    :return: it returns the new list generated by adding the values that meet the if requirements
    and the count of the new list.
    """
    list_null_complete = []  # creating a new list
    count = 0  # count starts at 0
    for linea_i in list_null:  # runs every element in the list
        if linea_i[column] == equal_null:  # checks if the value in the specific column matches the string constant
            list_null_complete.append(linea_i)  # if so it adds it to the new list
            count += 1  # It adds 1 with each new element added to the list.

    return list_null_complete, count


def empty(list_post, column):
    """
    Takes the empty values from a list generating a new list with only the values meeting the requirements.
    :param list_post: the list from where we extract the values.
    :param column: the specific column where the values we want are at.
    :return: it returns the new list generated by adding the values that meet the if requirements
    and the count of the new list.
    """
    list_empty = []  # creating a new list
    count = 0  # count starts at 0
    for linea_i in list_post:  # runs every element in the list
        if len(linea_i[column]) == 0:  # checks if the length of the value on the specific column is 0
            list_empty.append(linea_i)  # if so it adds it to the new list
            count += 1  # It adds 1 with each new element added to the list.

    return list_empty, count


def counts(lists, count):
    """
    Compares the length of the list with the counts
    :param lists: the list we want to work with
    :param count: the count we are using to compare the count to
    :return: True, if the length of the list matches the count and False if not.
    """
    for idx, val in enumerate(lists):  # idx is the index for each item of the list, therefore it runs every item of
        # the list one by one, [the length of lists is 2, meaning that that list has two items, each of this items can
        # be accessed like this lists[0], lists[1], etc. Inside of the [] is where the list we are using
        # to compare is at

        if len(lists[idx]) != count[idx]:
            # when the length of each item of our list is different from the count it returns False
            return False
    return True  # Once it has gone through every item of the list it returns True.

